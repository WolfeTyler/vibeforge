import { Contract, PromptPlatform } from "@/lib/types";

export function generateMarkdown(contract: Contract): string {
  const sections: string[] = [];

  sections.push(`# Forge Contract: ${contract.archetype} MVP`);
  sections.push(`> **Status:** Draft  `);
  sections.push(`> **Style:** ${contract.uiStyle}  `);
  sections.push(`> **Auth:** ${contract.auth}`);

  sections.push(`\n## 1. Goal\n${contract.goal || "TBD"}`);
  sections.push(`\n## 2. Target Users\n${contract.targetUsers || "TBD"}`);

  if (contract.successMetric && contract.successMetric !== "TBD") {
    sections.push(`\n## 3. Success Metric\n${contract.successMetric}`);
  }

  if (contract.coreFlows.length > 0) {
    sections.push(`\n## 4. Core Flows\n${contract.coreFlows.map(f => `- ${f}`).join("\n")}`);
  }

  if (contract.mvpScope.length > 0) {
    sections.push(`\n## 5. MVP Scope\n${contract.mvpScope.map(s => `- ${s}`).join("\n")}`);
  }

  if (contract.entities.length > 0) {
    sections.push(`\n## 6. Entities (Data Model)\n${contract.entities.map(e => `- **${e.name}**: [${e.fields.join(", ")}]`).join("\n")}`);
  }

  if (contract.nonGoals.length > 0) {
    sections.push(`\n## 7. Non-Goals\n${contract.nonGoals.map(n => `- ${n}`).join("\n")}`);
  }

  if (contract.roles.length > 0) {
    sections.push(`\n## 8. Roles\n${contract.roles.map(r => `- ${r}`).join("\n")}`);
  }

  if (contract.integrations.length > 0) {
    sections.push(`\n## 9. Integrations\n${contract.integrations.map(i => `- ${i}`).join("\n")}`);
  }

  sections.push(`\n## Definition of Done\n${contract.definitionOfDone.map(d => `- [ ] ${d}`).join("\n")}`);
  sections.push(`\n---\n*Generated by VibeForge*`);

  return sections.join("\n");
}

const PLATFORM_CONFIG: Record<PromptPlatform, { name: string; role: string; stackNote: string; platformRules: string[]; platformConstraints: string[] }> = {
  replit: {
    name: "Replit Agent",
    role: "You are Replit Agent, an autonomous AI software engineer with deep expertise in full-stack web development. You build production-quality web applications inside the Replit environment. You specialize in rapid prototyping, clean architecture, and shipping working MVPs fast.",
    stackNote: "Replit-native stack: React + Vite + Tailwind for the frontend, Node.js + Express for the backend, and PostgreSQL with Drizzle ORM for persistence. Bind the server to 0.0.0.0:5000.",
    platformRules: [
      "Always persist data to PostgreSQL — never rely on localStorage for important user data.",
      "Use the built-in PostgreSQL database (Neon-backed) via DATABASE_URL environment variable.",
      "Prefer simple session-based auth unless the contract specifies otherwise.",
      "Build mobile-first responsive layouts using Tailwind breakpoints.",
    ],
    platformConstraints: [
      "Do NOT use Docker, virtual environments, or containerization — Replit uses Nix.",
      "Do NOT add dependencies not listed in the tech stack without explicit approval.",
      "All server routes must be on port 5000 bound to 0.0.0.0.",
      "Do NOT store secrets in code — use environment variables.",
    ],
  },
  vibecodeapp: {
    name: "Vibe Codeapp",
    role: "You are a senior AI coding assistant specializing in building full-stack web applications from detailed specifications. You follow contracts precisely and produce production-quality, deployable code with proper error handling and clean architecture.",
    stackNote: "Modern web stack: React or Next.js for the frontend, Node.js or Python for the backend, and PostgreSQL or SQLite for persistence. Choose based on project complexity.",
    platformRules: [
      "Produce clean, well-structured code with proper error handling at every layer.",
      "Include environment variable management for all secrets and API keys.",
      "Write TypeScript for type safety wherever possible.",
      "Build mobile-first responsive layouts.",
    ],
    platformConstraints: [
      "Ensure the app can be deployed to any cloud platform without modification.",
      "Do NOT hardcode configuration values — use environment variables.",
      "Do NOT add dependencies not listed in the tech stack without explicit approval.",
      "All API responses must include proper HTTP status codes and error messages.",
    ],
  },
  cursor: {
    name: "Cursor AI",
    role: "You are Cursor, an AI-powered code editor assistant specializing in incremental, test-driven development. You build applications step by step, following the contract as the single source of truth. You break work into small, verifiable commits.",
    stackNote: "Standard modern stack: React + Vite + Tailwind for frontend, Express or Next.js API routes for backend, and Prisma + PostgreSQL or SQLite for the database layer.",
    platformRules: [
      "Break implementation into small, testable commits — one feature per commit.",
      "Write TypeScript throughout — avoid `any` types.",
      "Create proper project structure with clear separation of concerns.",
      "Reference the contract before implementing each feature to prevent drift.",
      "Include a README.md with setup instructions.",
    ],
    platformConstraints: [
      "Do NOT implement features not specified in the contract without asking.",
      "Do NOT refactor working code unless explicitly requested.",
      "Do NOT add dependencies not listed in the tech stack without explicit approval.",
      "Keep files under 300 lines — split into modules when they grow.",
    ],
  },
  generic: {
    name: "AI Code Assistant",
    role: "You are a senior full-stack engineer and product architect with 10+ years of experience shipping production web applications. You specialize in building clean, maintainable MVPs that solve real user problems. You follow specifications precisely and never add features that weren't requested.",
    stackNote: "Choose an appropriate modern web stack based on the project requirements. Suggested: React/Vue/Svelte for frontend, Node.js/Python/Go for backend, PostgreSQL/SQLite for database.",
    platformRules: [
      "Follow best practices for the chosen stack.",
      "Include proper error handling and input validation at every layer.",
      "Write clean, maintainable, well-organized code.",
      "Build mobile-first responsive layouts.",
      "Persist all user data to a database — never rely on client-only storage for important information.",
    ],
    platformConstraints: [
      "Do NOT add features not specified in the contract.",
      "Do NOT add dependencies without explicit approval.",
      "Do NOT store secrets in code — use environment variables.",
      "All API endpoints must validate input and return proper error responses.",
    ],
  },
};

const ARCHETYPE_ANTI_PATTERNS: Record<string, { bad: string; why: string }[]> = {
  saas_crud: [
    { bad: "Building a complex RBAC permission system for the MVP.", why: "Start with simple role checks (admin vs user). Over-engineered permissions waste weeks and the requirements will change." },
    { bad: "Creating a custom data grid component from scratch.", why: "Use an existing table/grid library. Custom grids are massive time sinks with sorting, filtering, pagination edge cases." },
    { bad: "Adding real-time collaboration features in v1.", why: "WebSocket-based collaboration is complex. Ship with standard request/response first, add real-time later if needed." },
    { bad: "Building email notification templates before core CRUD works.", why: "Notifications are polish. Get the data model and flows working first." },
  ],
  marketplace: [
    { bad: "Building a custom payment processing system from scratch.", why: "Use Stripe or a payment service. Custom payment handling has massive security and compliance implications." },
    { bad: "Implementing a recommendation engine in the MVP.", why: "Recommendations require data you don't have yet. Show recent/popular items first. Add ML later when you have usage data." },
    { bad: "Building a real-time chat system between buyers and sellers.", why: "Chat is a separate product. Start with a simple messaging/contact form. Add real-time chat in v2." },
    { bad: "Creating an elaborate review and rating system with fraud detection.", why: "Start with simple star ratings and text reviews. Fraud detection is a post-launch optimization." },
  ],
  booking: [
    { bad: "Building a custom calendar component from scratch.", why: "Use an existing calendar library (react-big-calendar, fullcalendar). Custom calendars take weeks to handle edge cases." },
    { bad: "Implementing complex recurring booking patterns in v1.", why: "Start with one-time bookings. Recurring patterns (every 2nd Tuesday, etc.) are surprisingly complex." },
    { bad: "Adding payment processing before the booking flow works.", why: "Get the booking flow working end-to-end first. Payment is a layer on top of a working reservation system." },
    { bad: "Building timezone handling manually.", why: "Use a library like date-fns-tz or luxon. Manual timezone math is a bug factory." },
  ],
  ai_tool: [
    { bad: "Fine-tuning or training a custom model for the MVP.", why: "Use existing API models (OpenAI, Anthropic, etc.). Fine-tuning requires data and expertise you likely don't have yet." },
    { bad: "Building a custom streaming response handler from scratch.", why: "Use the SDK's built-in streaming support. Custom stream parsing is fragile and error-prone." },
    { bad: "Storing every AI conversation permanently without a retention policy.", why: "AI conversations generate massive amounts of data. Set retention limits from day one." },
    { bad: "Trying to eliminate all AI hallucinations before launching.", why: "You can't. Add disclaimers, implement fact-checking for critical outputs, and iterate based on user feedback." },
  ],
  social: [
    { bad: "Building a custom real-time notification system from scratch.", why: "Use a service like Pusher or polling. Real-time infrastructure is a separate engineering challenge." },
    { bad: "Implementing a custom media upload and processing pipeline.", why: "Use a service like Cloudinary or S3 with pre-signed URLs. Media processing is infrastructure, not product." },
    { bad: "Building a complex feed ranking algorithm for launch.", why: "Start with reverse chronological. You need usage data before ranking makes sense." },
    { bad: "Adding direct messaging, stories, and live streaming all at once.", why: "Each is a product in itself. Pick the ONE social feature that defines your app and nail it." },
  ],
  ecommerce: [
    { bad: "Building custom payment processing instead of using Stripe/PayPal.", why: "Payment processing has PCI compliance requirements. Use a payment service — it's not optional." },
    { bad: "Implementing a custom inventory management system in v1.", why: "Start with simple stock counts. Complex inventory (warehouses, variants, backorders) is a v2 feature." },
    { bad: "Building a custom shipping calculator.", why: "Integrate with a shipping API (EasyPost, ShipStation). Shipping rate calculation is surprisingly complex." },
    { bad: "Adding product recommendations before you have customer data.", why: "Show 'related products' by category first. ML-based recommendations need purchase history to work." },
  ],
  project_management: [
    { bad: "Building Gantt charts from scratch.", why: "Use an existing Gantt library or skip Gantt entirely for the MVP. A kanban board is simpler and often more useful." },
    { bad: "Implementing real-time collaborative editing of documents.", why: "Real-time collaboration (like Google Docs) requires CRDT or OT algorithms. Way too complex for an MVP." },
    { bad: "Building complex permission hierarchies (org > team > project > task).", why: "Start with two roles: admin and member. Add hierarchy when you have real users requesting it." },
    { bad: "Adding time tracking, invoicing, and resource allocation all at once.", why: "Each is a product. Build task management first, then layer features based on user demand." },
  ],
  blog_cms: [
    { bad: "Building a custom rich text editor from scratch.", why: "Use Tiptap, Slate, or TinyMCE. Rich text editors are incredibly complex — don't reinvent the wheel." },
    { bad: "Implementing a custom image optimization and CDN pipeline.", why: "Use Cloudinary, imgix, or Next.js Image. Image optimization is infrastructure, not product." },
    { bad: "Building SEO tooling into the CMS before content exists.", why: "Focus on content creation first. SEO features matter when you have content to optimize." },
    { bad: "Adding multi-language support in the MVP.", why: "i18n adds complexity to every component. Launch in one language, add translations when you have traction." },
  ],
  analytics_dashboard: [
    { bad: "Building custom chart components instead of using a charting library.", why: "Use Recharts, Chart.js, or D3 wrappers. Custom SVG charts take weeks to get right." },
    { bad: "Implementing real-time streaming analytics for the MVP.", why: "Start with periodic refresh (every 30s-60s). Real-time streaming requires different infrastructure." },
    { bad: "Building a custom query builder UI.", why: "Pre-built dashboards with filters work for 90% of use cases. Custom queries are a power-user feature for later." },
    { bad: "Trying to support every possible data source at launch.", why: "Support ONE data source well. Add connectors incrementally based on demand." },
  ],
  education: [
    { bad: "Building a custom video player and streaming infrastructure.", why: "Use YouTube embeds, Vimeo, or Mux. Video infrastructure is expensive and complex." },
    { bad: "Implementing AI-powered adaptive learning paths in v1.", why: "Start with manual course sequencing. Adaptive learning requires usage data and significant ML work." },
    { bad: "Building a proctored exam system from scratch.", why: "Online proctoring is a specialized product with legal implications. Use a service or skip for MVP." },
    { bad: "Adding gamification (badges, leaderboards, XP) before core learning works.", why: "Gamification is polish. Get the course content and completion tracking working first." },
  ],
  game: [
    { bad: "Building a custom game engine or physics system.", why: "Use an existing library (Phaser, PixiJS, Three.js). Game engines take years to build properly." },
    { bad: "Implementing multiplayer networking before single-player works.", why: "Get the core game loop working solo first. Multiplayer networking is a separate engineering challenge." },
    { bad: "Building an in-game economy with real money transactions for MVP.", why: "Virtual economies have legal and fraud implications. Start with simple progression systems." },
    { bad: "Adding procedural content generation before hand-crafted content exists.", why: "Procedural generation needs tuning parameters. Create manual content first to understand what 'good' looks like." },
  ],
  personal_site: [
    { bad: "Building a custom CMS backend for a portfolio site.", why: "Use static content, markdown files, or a headless CMS. A custom backend for a personal site is overkill." },
    { bad: "Implementing a custom analytics tracking system.", why: "Use Plausible, Fathom, or even simple Vercel Analytics. Don't build what you can buy for $5/month." },
    { bad: "Adding a blog, portfolio, contact form, and e-commerce all at once.", why: "Pick the ONE thing your personal site needs to do well. Add sections incrementally." },
    { bad: "Over-engineering animations and transitions before content is ready.", why: "Content-first. A beautifully animated site with no content is just a tech demo." },
  ],
};

function getAntiPatterns(contract: Contract): { bad: string; why: string }[] {
  const patterns: { bad: string; why: string }[] = [];

  const archetypePatterns = ARCHETYPE_ANTI_PATTERNS[contract.archetype] || [];
  patterns.push(...archetypePatterns);

  contract.nonGoals.forEach(ng => {
    patterns.push({
      bad: `Implementing "${ng}" in this MVP.`,
      why: "This was explicitly marked as a non-goal. Do not build it, plan for it, or create infrastructure to support it later."
    });
  });

  return patterns;
}

export function generatePrompt(contract: Contract, platform: PromptPlatform): string {
  const config = PLATFORM_CONFIG[platform];
  const s: string[] = [];

  s.push(`<role>`);
  s.push(config.role);
  s.push(`</role>`);

  s.push(``);
  s.push(`<mission>`);
  s.push(`Build a complete, working MVP for: "${contract.ideaText}"`);
  s.push(``);
  s.push(`Archetype: ${contract.archetype}`);
  s.push(`Goal: ${contract.goal || "TBD"}`);
  s.push(`Target Users: ${contract.targetUsers || "TBD"}`);
  if (contract.successMetric && contract.successMetric !== "TBD") {
    s.push(`Success Metric: ${contract.successMetric}`);
  }
  s.push(``);
  s.push(`Deliver a fully functional application where every core flow works end-to-end with real data persistence. No mock data. No placeholder pages. Every feature listed in MVP Scope must be implemented and testable.`);
  s.push(`</mission>`);

  s.push(``);
  s.push(`<context>`);
  s.push(`App Idea: ${contract.ideaText}`);
  s.push(`UI Style: ${contract.uiStyle}`);
  s.push(`Auth Strategy: ${contract.auth}`);
  s.push(`Deployment Target: ${contract.deployment}`);
  if (contract.roles.length > 0) {
    s.push(`User Roles: ${contract.roles.join(", ")}`);
  }
  if (contract.integrations.length > 0) {
    s.push(`External Integrations: ${contract.integrations.join(", ")}`);
  }
  s.push(``);
  s.push(`Tech Stack:`);
  s.push(config.stackNote);
  if (contract.stackPrefs.frontend) s.push(`- Frontend: ${contract.stackPrefs.frontend}`);
  if (contract.stackPrefs.backend) s.push(`- Backend: ${contract.stackPrefs.backend}`);
  if (contract.stackPrefs.db) s.push(`- Database: ${contract.stackPrefs.db}`);
  if (contract.entities.length > 0) {
    s.push(``);
    s.push(`Data Model:`);
    contract.entities.forEach(e => {
      s.push(`- ${e.name}: [${e.fields.join(", ")}]`);
    });
  }
  s.push(`</context>`);

  s.push(``);
  s.push(`<rules>`);
  s.push(`Never assume requirements that aren't explicitly stated in this prompt. If something is ambiguous, implement the simplest reasonable version.`);
  s.push(`Never add features beyond what's listed in MVP Scope. Scope creep is the #1 cause of broken MVPs.`);
  s.push(`Never use placeholder or mock data in production code paths. All data must be persisted to the database.`);
  s.push(`Never skip error handling. Every user action must have success and failure states.`);
  s.push(`Always build mobile-first. Design for small screens, then enhance for desktop.`);
  s.push(`Always validate user input on both client and server.`);
  s.push(`Always use the exact tech stack specified — do not swap libraries or frameworks.`);
  config.platformRules.forEach(r => {
    s.push(r);
  });
  if (contract.nonNegotiables.length > 0) {
    s.push(``);
    s.push(`Non-negotiable requirements (these MUST be met):`);
    contract.nonNegotiables.forEach(n => {
      s.push(`- ${n}`);
    });
  }
  s.push(`</rules>`);

  s.push(``);
  s.push(`<constraints>`);
  config.platformConstraints.forEach(c => {
    s.push(c);
  });
  if (contract.nonGoals.length > 0) {
    s.push(``);
    s.push(`Explicitly OUT OF SCOPE (do NOT build):`);
    contract.nonGoals.forEach(n => {
      s.push(`- ${n}`);
    });
  }
  s.push(`</constraints>`);

  if (contract.coreFlows.length > 0 || contract.mvpScope.length > 0) {
    s.push(``);
    s.push(`<method>`);
    s.push(`Follow this build sequence. Complete each step fully before moving to the next. Do not skip ahead.`);
    s.push(``);
    s.push(`1. Initialize the project with the specified tech stack. Set up folder structure and install dependencies.`);
    s.push(`2. Define the database schema for all entities: ${contract.entities.map(e => e.name).join(", ") || "TBD"}.`);
    s.push(`3. Build API routes for each entity (CRUD operations with proper validation).`);
    if (contract.auth !== "none") {
      s.push(`4. Implement authentication (${contract.auth}) with signup, login, and logout flows.`);
    }
    if (contract.coreFlows.length > 0) {
      s.push(`${contract.auth !== "none" ? "5" : "4"}. Implement core user flows end-to-end:`);
      contract.coreFlows.forEach((flow, i) => {
        s.push(`   ${i + 1}. ${flow}`);
      });
    }
    if (contract.mvpScope.length > 0) {
      const stepNum = (contract.auth !== "none" ? 5 : 4) + (contract.coreFlows.length > 0 ? 1 : 0);
      s.push(`${stepNum}. Implement remaining MVP scope items:`);
      contract.mvpScope.forEach(item => {
        s.push(`   - ${item}`);
      });
    }
    s.push(`${(contract.auth !== "none" ? 5 : 4) + (contract.coreFlows.length > 0 ? 1 : 0) + (contract.mvpScope.length > 0 ? 1 : 0)}. Style the entire UI to match the "${contract.uiStyle}" design aesthetic.`);
    s.push(`${(contract.auth !== "none" ? 5 : 4) + (contract.coreFlows.length > 0 ? 1 : 0) + (contract.mvpScope.length > 0 ? 1 : 0) + 1}. Test every flow end-to-end. Verify all acceptance criteria pass.`);
    s.push(`</method>`);
  }

  const antiPatterns = getAntiPatterns(contract);
  if (antiPatterns.length > 0) {
    s.push(``);
    s.push(`<anti_patterns>`);
    s.push(`These are common mistakes for this type of project. Avoid all of them.`);
    antiPatterns.forEach(ap => {
      s.push(``);
      s.push(`BAD: ${ap.bad}`);
      s.push(`WHY: ${ap.why}`);
    });
    s.push(`</anti_patterns>`);
  }

  s.push(``);
  s.push(`<fallback>`);
  s.push(`If you encounter ambiguity in the requirements:`);
  s.push(`1. Implement the simplest reasonable version that satisfies the stated goal.`);
  s.push(`2. Add a code comment noting the assumption you made and why.`);
  s.push(`3. Do NOT stop and ask — make a pragmatic decision and keep building.`);
  s.push(``);
  s.push(`If you cannot complete a feature due to missing API keys, external services, or infrastructure:`);
  s.push(`1. Stub the integration with a clear interface/abstraction.`);
  s.push(`2. Add a TODO comment with exactly what's needed to complete it.`);
  s.push(`3. Ensure the rest of the app works without the integration.`);
  s.push(``);
  s.push(`Never hallucinate functionality. Never fake API responses. Never hardcode data that should come from a database.`);
  s.push(`</fallback>`);

  s.push(``);
  s.push(`<output_format>`);
  s.push(`Deliver a complete, working application with:`);
  s.push(`- All database tables created and migrated`);
  s.push(`- All API endpoints implemented with validation and error handling`);
  s.push(`- All UI components styled to the "${contract.uiStyle}" aesthetic`);
  s.push(`- All core flows working end-to-end with real data persistence`);
  if (contract.auth !== "none") {
    s.push(`- Authentication fully functional (${contract.auth})`);
  }
  s.push(`- Responsive layout (mobile, tablet, desktop)`);
  s.push(`</output_format>`);

  s.push(``);
  s.push(`<evaluation>`);
  s.push(`Before considering the app complete, verify:`);
  contract.definitionOfDone.forEach(d => {
    s.push(`- [ ] ${d}`);
  });
  s.push(`- [ ] No console errors in the browser`);
  s.push(`- [ ] No unhandled server errors`);
  s.push(`- [ ] All forms validate input and show error states`);
  s.push(`- [ ] The app works on mobile screen sizes`);
  s.push(`- [ ] No hardcoded/mock data in production code paths`);
  s.push(`</evaluation>`);

  return s.join("\n");
}

export function generatePRD(contract: Contract): string {
  const s: string[] = [];

  s.push(`# Product Requirements Document: ${contract.archetype} MVP`);
  s.push(`\n> Generated by VibeForge — Single source of truth for product scope and requirements.`);

  s.push(`\n## 1. Project Overview`);
  s.push(`\n**Idea:** ${contract.ideaText}`);
  s.push(`**Archetype:** ${contract.archetype}`);
  s.push(`**Deployment Target:** ${contract.deployment}`);
  s.push(`**UI Style:** ${contract.uiStyle}`);
  s.push(`**Authentication:** ${contract.auth}`);

  s.push(`\n## 2. Goal`);
  s.push(`\n${contract.goal || "TBD"}`);

  s.push(`\n## 3. Target Users`);
  s.push(`\n${contract.targetUsers || "TBD"}`);

  s.push(`\n## 4. Success Metrics`);
  s.push(`\n${contract.successMetric && contract.successMetric !== "TBD" ? contract.successMetric : "To be defined based on initial launch data."}`);

  s.push(`\n## 5. User Stories`);
  if (contract.roles.length > 0 && contract.coreFlows.length > 0) {
    contract.roles.forEach(role => {
      s.push(`\n### As a ${role}:`);
      contract.coreFlows.forEach((flow, i) => {
        s.push(`- US-${role.replace(/\s+/g, "").substring(0, 3).toUpperCase()}${i + 1}: As a ${role}, I want to ${flow.toLowerCase()} so that I can accomplish my goals efficiently.`);
      });
    });
  } else if (contract.coreFlows.length > 0) {
    s.push(`\n### As a user:`);
    contract.coreFlows.forEach((flow, i) => {
      s.push(`- US-${i + 1}: As a user, I want to ${flow.toLowerCase()} so that I can accomplish my goals efficiently.`);
    });
  }

  s.push(`\n## 6. Feature List (MVP Scope)`);
  if (contract.mvpScope.length > 0) {
    s.push(`\n| # | Feature | Priority |`);
    s.push(`|---|---------|----------|`);
    contract.mvpScope.forEach((feature, i) => {
      s.push(`| ${i + 1} | ${feature} | P0 — Must Have |`);
    });
  }

  s.push(`\n## 7. Non-Goals (Out of Scope)`);
  s.push(`\nThe following are explicitly excluded from this MVP:`);
  if (contract.nonGoals.length > 0) {
    contract.nonGoals.forEach(n => {
      s.push(`- ❌ ${n}`);
    });
  } else {
    s.push(`- No explicit non-goals defined.`);
  }

  s.push(`\n## 8. Data Entities`);
  if (contract.entities.length > 0) {
    contract.entities.forEach(e => {
      s.push(`\n### ${e.name}`);
      s.push(`Fields: ${e.fields.join(", ")}`);
    });
  }

  s.push(`\n## 9. User Roles`);
  if (contract.roles.length > 0) {
    contract.roles.forEach(r => {
      s.push(`- **${r}**`);
    });
  } else {
    s.push(`- Single user role (no role differentiation)`);
  }

  s.push(`\n## 10. Integrations`);
  if (contract.integrations.length > 0) {
    contract.integrations.forEach(int => {
      s.push(`- ${int}`);
    });
  } else {
    s.push(`- No external integrations required for MVP.`);
  }

  s.push(`\n## 11. Non-Negotiable Requirements`);
  if (contract.nonNegotiables.length > 0) {
    contract.nonNegotiables.forEach(n => {
      s.push(`- ⚠️ ${n}`);
    });
  } else {
    s.push(`- Standard quality and performance expectations apply.`);
  }

  s.push(`\n## 12. Acceptance Criteria (Definition of Done)`);
  s.push(`\nThe MVP is considered complete when ALL of the following are verified:`);
  if (contract.definitionOfDone.length > 0) {
    contract.definitionOfDone.forEach((d, i) => {
      s.push(`- [ ] AC-${i + 1}: ${d}`);
    });
  }

  s.push(`\n## 13. Scope Boundaries`);
  s.push(`\n- **In Scope:** All features listed in Section 6, all core flows, and all acceptance criteria.`);
  s.push(`- **Out of Scope:** All items listed in Section 7 (Non-Goals).`);
  s.push(`- **Deferred:** Performance optimization, advanced analytics, and internationalization unless explicitly listed above.`);

  s.push(`\n---\n*Generated by VibeForge*`);
  return s.join("\n");
}

function deriveRoutes(archetype: string, coreFlows: string[], auth: string): { path: string; page: string; description: string }[] {
  const routes: { path: string; page: string; description: string }[] = [];
  const lowerArchetype = archetype.toLowerCase();

  routes.push({ path: "/", page: "Home / Landing", description: "Main entry point and landing page" });

  if (auth !== "none") {
    routes.push({ path: "/login", page: "Login", description: "User authentication page" });
    routes.push({ path: "/register", page: "Register", description: "New user registration" });
  }

  if (lowerArchetype.includes("social")) {
    routes.push({ path: "/feed", page: "Feed", description: "Main content feed" });
    routes.push({ path: "/profile/:id", page: "Profile", description: "User profile view" });
    routes.push({ path: "/messages", page: "Messages", description: "Direct messaging" });
    routes.push({ path: "/notifications", page: "Notifications", description: "Activity notifications" });
  } else if (lowerArchetype.includes("marketplace") || lowerArchetype.includes("ecommerce") || lowerArchetype.includes("e-commerce")) {
    routes.push({ path: "/browse", page: "Browse / Catalog", description: "Browse available listings or products" });
    routes.push({ path: "/item/:id", page: "Item Detail", description: "Individual item/product view" });
    routes.push({ path: "/cart", page: "Cart", description: "Shopping cart" });
    routes.push({ path: "/checkout", page: "Checkout", description: "Payment and order completion" });
    routes.push({ path: "/orders", page: "Orders", description: "Order history" });
  } else if (lowerArchetype.includes("dashboard") || lowerArchetype.includes("analytics")) {
    routes.push({ path: "/dashboard", page: "Dashboard", description: "Main analytics dashboard" });
    routes.push({ path: "/reports", page: "Reports", description: "Detailed reports view" });
    routes.push({ path: "/settings", page: "Settings", description: "App and user settings" });
  } else if (lowerArchetype.includes("booking")) {
    routes.push({ path: "/search", page: "Search", description: "Search available bookings" });
    routes.push({ path: "/booking/:id", page: "Booking Detail", description: "View booking details" });
    routes.push({ path: "/book", page: "Book", description: "Create a new booking" });
    routes.push({ path: "/my-bookings", page: "My Bookings", description: "View user's bookings" });
  } else if (lowerArchetype.includes("blog") || lowerArchetype.includes("cms")) {
    routes.push({ path: "/posts", page: "Posts List", description: "Browse all posts" });
    routes.push({ path: "/post/:id", page: "Post Detail", description: "Read individual post" });
    routes.push({ path: "/editor", page: "Editor", description: "Create or edit content" });
    routes.push({ path: "/categories", page: "Categories", description: "Content categories" });
  } else if (lowerArchetype.includes("project") || lowerArchetype.includes("management")) {
    routes.push({ path: "/projects", page: "Projects", description: "List of all projects" });
    routes.push({ path: "/project/:id", page: "Project Detail", description: "Individual project view" });
    routes.push({ path: "/tasks", page: "Tasks", description: "Task board or list" });
    routes.push({ path: "/team", page: "Team", description: "Team members view" });
  } else if (lowerArchetype.includes("ai") || lowerArchetype.includes("tool")) {
    routes.push({ path: "/app", page: "App", description: "Main tool interface" });
    routes.push({ path: "/history", page: "History", description: "Previous results or sessions" });
    routes.push({ path: "/settings", page: "Settings", description: "Tool configuration" });
  } else if (lowerArchetype.includes("education") || lowerArchetype.includes("learning")) {
    routes.push({ path: "/courses", page: "Courses", description: "Browse available courses" });
    routes.push({ path: "/course/:id", page: "Course Detail", description: "Individual course view" });
    routes.push({ path: "/lesson/:id", page: "Lesson", description: "Lesson content view" });
    routes.push({ path: "/progress", page: "Progress", description: "Learning progress tracker" });
  } else {
    routes.push({ path: "/app", page: "Main App", description: "Primary application interface" });
  }

  coreFlows.forEach(flow => {
    const slug = flow.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "").substring(0, 20);
    const exists = routes.some(r => r.path.includes(slug));
    if (!exists && slug.length > 2) {
      routes.push({ path: `/${slug}`, page: flow, description: `Flow: ${flow}` });
    }
  });

  if (auth !== "none") {
    routes.push({ path: "/profile", page: "User Profile", description: "Current user's profile and settings" });
  }

  return routes;
}

export function generateAppFlow(contract: Contract): string {
  const s: string[] = [];

  s.push(`# APP_FLOW.md — ${contract.archetype} MVP`);
  s.push(`\n> Application flow documentation — screens, routes, user journeys, and navigation.`);

  const routes = deriveRoutes(contract.archetype, contract.coreFlows, contract.auth);

  s.push(`\n## 1. Page / Screen Inventory`);
  s.push(`\n| Route | Page | Description |`);
  s.push(`|-------|------|-------------|`);
  routes.forEach(r => {
    s.push(`| \`${r.path}\` | ${r.page} | ${r.description} |`);
  });

  s.push(`\n## 2. User Journey Flows`);
  if (contract.coreFlows.length > 0) {
    contract.coreFlows.forEach((flow, i) => {
      s.push(`\n### Flow ${i + 1}: ${flow}`);
      s.push(`\n**Trigger:** User initiates "${flow}"`);
      s.push(`\n**Steps:**`);
      s.push(`1. User navigates to the relevant page`);
      s.push(`2. System displays the ${flow.toLowerCase()} interface`);
      s.push(`3. User provides required input / performs action`);
      s.push(`4. System validates the input`);
      s.push(`5. System processes the request and updates the database`);
      s.push(`6. System displays success confirmation with updated state`);
      s.push(`7. User is redirected or shown the result`);
      s.push(`\n**Success Criteria:** The ${flow.toLowerCase()} is completed and persisted.`);
      s.push(`\n**Error States:**`);
      s.push(`- Invalid input → Show inline validation errors with specific messages`);
      s.push(`- Network failure → Show retry option with "Connection lost" message`);
      s.push(`- Server error → Show user-friendly error with support contact`);
      s.push(`- Unauthorized → Redirect to login page with return URL`);
    });
  }

  s.push(`\n## 3. Navigation Structure`);
  s.push(`\n### Primary Navigation`);
  const primaryRoutes = routes.filter(r => !r.path.includes(":") && r.path !== "/login" && r.path !== "/register");
  primaryRoutes.forEach(r => {
    s.push(`- **${r.page}** → \`${r.path}\``);
  });

  s.push(`\n### Secondary Navigation`);
  if (contract.auth !== "none") {
    s.push(`- User menu (avatar dropdown): Profile, Settings, Logout`);
  }
  s.push(`- Mobile: Bottom tab bar or hamburger menu`);
  s.push(`- Breadcrumbs for nested pages`);

  s.push(`\n## 4. Error States & Edge Cases`);
  s.push(`\n### Global Error States`);
  s.push(`- **404 Not Found:** Custom page with navigation back to home`);
  s.push(`- **500 Server Error:** Friendly error page with retry button`);
  s.push(`- **Network Offline:** Banner notification with auto-retry`);
  s.push(`- **Session Expired:** Redirect to login with "session expired" message`);
  s.push(`\n### Data Edge Cases`);
  s.push(`- **Empty States:** Show helpful illustrations and CTAs when lists are empty`);
  s.push(`- **Loading States:** Skeleton screens for initial loads, spinners for actions`);
  s.push(`- **Pagination:** Infinite scroll or paginated lists for large datasets`);
  s.push(`- **Concurrent Edits:** Last-write-wins with conflict notification`);

  if (contract.auth !== "none") {
    s.push(`\n## 5. Authentication Flows`);
    s.push(`\n### Auth Strategy: ${contract.auth}`);

    if (contract.auth === "email_password") {
      s.push(`\n**Registration Flow:**`);
      s.push(`1. User clicks "Sign Up"`);
      s.push(`2. User enters email and password`);
      s.push(`3. System validates email format and password strength (min 8 chars, 1 uppercase, 1 number)`);
      s.push(`4. System creates account and sends verification email`);
      s.push(`5. User is logged in and redirected to main app`);
      s.push(`\n**Login Flow:**`);
      s.push(`1. User enters email and password`);
      s.push(`2. System validates credentials`);
      s.push(`3. On success: Create session, redirect to app`);
      s.push(`4. On failure: Show "Invalid email or password" (generic for security)`);
      s.push(`\n**Password Reset:**`);
      s.push(`1. User clicks "Forgot Password"`);
      s.push(`2. User enters email`);
      s.push(`3. System sends reset link (valid for 1 hour)`);
      s.push(`4. User sets new password`);
    } else if (contract.auth === "oauth_google") {
      s.push(`\n**OAuth Flow:**`);
      s.push(`1. User clicks "Sign in with Google"`);
      s.push(`2. Redirect to Google OAuth consent screen`);
      s.push(`3. User authorizes the application`);
      s.push(`4. Google redirects back with auth code`);
      s.push(`5. Server exchanges code for tokens`);
      s.push(`6. Server creates/updates user record`);
      s.push(`7. User is logged in and redirected to main app`);
    } else if (contract.auth === "magic_link") {
      s.push(`\n**Magic Link Flow:**`);
      s.push(`1. User enters email address`);
      s.push(`2. System sends a one-time login link (valid for 15 minutes)`);
      s.push(`3. User clicks link in email`);
      s.push(`4. System validates token and creates session`);
      s.push(`5. User is logged in and redirected to main app`);
    }

    s.push(`\n**Logout Flow:**`);
    s.push(`1. User clicks "Logout"`);
    s.push(`2. System destroys session`);
    s.push(`3. User is redirected to landing page`);

    s.push(`\n**Protected Routes:**`);
    const protectedRoutes = routes.filter(r => r.path !== "/" && r.path !== "/login" && r.path !== "/register");
    protectedRoutes.forEach(r => {
      s.push(`- \`${r.path}\` — Requires authentication`);
    });
  }

  s.push(`\n---\n*Generated by VibeForge*`);
  return s.join("\n");
}

export function generateTechStack(contract: Contract): string {
  const s: string[] = [];
  const frontend = contract.stackPrefs.frontend || "React";
  const backend = contract.stackPrefs.backend || "Node.js + Express";
  const db = contract.stackPrefs.db || "PostgreSQL";

  s.push(`# TECH_STACK.md — ${contract.archetype} MVP`);
  s.push(`\n> Technology choices, versions, and infrastructure configuration.`);

  s.push(`\n## Frontend`);
  s.push(`\n| Technology | Version | Purpose |`);
  s.push(`|------------|---------|---------|`);
  if (frontend.toLowerCase().includes("react")) {
    s.push(`| React | ^18.3 | UI library |`);
    s.push(`| Vite | ^5.4 | Build tool and dev server |`);
    s.push(`| TypeScript | ^5.6 | Type safety |`);
    s.push(`| Tailwind CSS | ^3.4 | Utility-first CSS framework |`);
    s.push(`| Wouter | ^3.3 | Client-side routing |`);
    s.push(`| TanStack Query | ^5.60 | Server state management |`);
    s.push(`| React Hook Form | ^7.53 | Form handling |`);
    s.push(`| Zod | ^3.23 | Schema validation |`);
  } else if (frontend.toLowerCase().includes("next")) {
    s.push(`| Next.js | ^14.2 | Full-stack React framework |`);
    s.push(`| TypeScript | ^5.6 | Type safety |`);
    s.push(`| Tailwind CSS | ^3.4 | Utility-first CSS framework |`);
    s.push(`| Zod | ^3.23 | Schema validation |`);
  } else if (frontend.toLowerCase().includes("vue")) {
    s.push(`| Vue.js | ^3.5 | UI framework |`);
    s.push(`| Vite | ^5.4 | Build tool and dev server |`);
    s.push(`| TypeScript | ^5.6 | Type safety |`);
    s.push(`| Tailwind CSS | ^3.4 | Utility-first CSS framework |`);
    s.push(`| Vue Router | ^4.4 | Client-side routing |`);
    s.push(`| Pinia | ^2.2 | State management |`);
  } else if (frontend.toLowerCase().includes("svelte")) {
    s.push(`| SvelteKit | ^2.8 | Full-stack Svelte framework |`);
    s.push(`| TypeScript | ^5.6 | Type safety |`);
    s.push(`| Tailwind CSS | ^3.4 | Utility-first CSS framework |`);
  } else {
    s.push(`| ${frontend} | latest | Frontend framework |`);
    s.push(`| TypeScript | ^5.6 | Type safety |`);
    s.push(`| Tailwind CSS | ^3.4 | Utility-first CSS framework |`);
  }

  s.push(`\n## Backend`);
  s.push(`\n| Technology | Version | Purpose |`);
  s.push(`|------------|---------|---------|`);
  if (backend.toLowerCase().includes("express") || backend.toLowerCase().includes("node")) {
    s.push(`| Node.js | ^20 | Runtime |`);
    s.push(`| Express | ^4.21 | HTTP server framework |`);
    s.push(`| TypeScript | ^5.6 | Type safety |`);
    s.push(`| tsx | ^4.19 | TypeScript execution |`);
  } else if (backend.toLowerCase().includes("python") || backend.toLowerCase().includes("flask") || backend.toLowerCase().includes("fastapi")) {
    s.push(`| Python | ^3.11 | Runtime |`);
    if (backend.toLowerCase().includes("fastapi")) {
      s.push(`| FastAPI | ^0.115 | HTTP framework |`);
      s.push(`| Uvicorn | ^0.32 | ASGI server |`);
    } else {
      s.push(`| Flask | ^3.1 | HTTP framework |`);
    }
  } else {
    s.push(`| ${backend} | latest | Backend framework |`);
  }

  s.push(`\n## Database`);
  s.push(`\n| Technology | Version | Purpose |`);
  s.push(`|------------|---------|---------|`);
  if (db.toLowerCase().includes("postgres")) {
    s.push(`| PostgreSQL | ^16 | Primary database |`);
    s.push(`| Drizzle ORM | ^0.36 | TypeScript ORM |`);
    s.push(`| Drizzle Kit | ^0.28 | Migration tooling |`);
    s.push(`| drizzle-zod | ^0.5 | Schema-to-Zod integration |`);
  } else if (db.toLowerCase().includes("sqlite")) {
    s.push(`| SQLite | ^3.45 | Primary database |`);
    s.push(`| Drizzle ORM | ^0.36 | TypeScript ORM |`);
    s.push(`| better-sqlite3 | ^11.6 | SQLite driver |`);
  } else if (db.toLowerCase().includes("mongo")) {
    s.push(`| MongoDB | ^7.0 | Primary database |`);
    s.push(`| Mongoose | ^8.8 | ODM |`);
  } else {
    s.push(`| ${db} | latest | Primary database |`);
  }

  s.push(`\n## Infrastructure`);
  s.push(`\n| Component | Detail |`);
  s.push(`|-----------|--------|`);
  s.push(`| Deployment | ${contract.deployment === "replit" ? "Replit Deployments" : contract.deployment === "local" ? "Local / Self-hosted" : "Cloud Platform (TBD)"} |`);
  s.push(`| Hosting | ${contract.deployment === "replit" ? "Replit (Nix-based container)" : "Cloud VM or PaaS"} |`);
  if (contract.deployment === "replit") {
    s.push(`| Port | 0.0.0.0:5000 (required by Replit) |`);
    s.push(`| Database Host | Neon-backed PostgreSQL via DATABASE_URL |`);
  }
  s.push(`| Environment | ${contract.deployment === "replit" ? "Nix (no Docker)" : "Docker or native"} |`);

  s.push(`\n## Dev Tools`);
  s.push(`\n| Tool | Purpose |`);
  s.push(`|------|---------|`);
  s.push(`| ESLint | Code linting |`);
  s.push(`| Prettier | Code formatting |`);
  s.push(`| TypeScript | Static type checking |`);
  if (db.toLowerCase().includes("postgres") || db.toLowerCase().includes("sqlite")) {
    s.push(`| Drizzle Studio | Database GUI |`);
  }
  s.push(`| Vite | Hot module replacement |`);

  if (contract.integrations.length > 0) {
    s.push(`\n## External Integrations`);
    s.push(`\n| Integration | Notes |`);
    s.push(`|-------------|-------|`);
    contract.integrations.forEach(int => {
      s.push(`| ${int} | Requires API key / configuration |`);
    });
  }

  s.push(`\n---\n*Generated by VibeForge*`);
  return s.join("\n");
}

const DESIGN_TOKENS: Record<string, {
  colors: Record<string, string>;
  fonts: { heading: string; body: string; mono: string };
  radii: Record<string, string>;
  shadows: Record<string, string>;
  timing: string;
  notes: string;
}> = {
  minimal: {
    colors: {
      primary: "#111111",
      secondary: "#6B7280",
      background: "#FFFFFF",
      surface: "#F9FAFB",
      text: "#111827",
      "text-secondary": "#6B7280",
      border: "#E5E7EB",
      success: "#10B981",
      error: "#EF4444",
      warning: "#F59E0B",
    },
    fonts: { heading: "Inter, system-ui, sans-serif", body: "Inter, system-ui, sans-serif", mono: "JetBrains Mono, monospace" },
    radii: { sm: "4px", md: "8px", lg: "12px", full: "9999px" },
    shadows: {
      sm: "0 1px 2px rgba(0,0,0,0.05)",
      md: "0 4px 6px rgba(0,0,0,0.07)",
      lg: "0 10px 15px rgba(0,0,0,0.1)",
    },
    timing: "150ms ease",
    notes: "Clean whites, generous whitespace, subtle borders. Focus on typography and content hierarchy.",
  },
  modern: {
    colors: {
      primary: "#6366F1",
      secondary: "#8B5CF6",
      background: "#FFFFFF",
      surface: "#F8FAFC",
      text: "#0F172A",
      "text-secondary": "#64748B",
      border: "#E2E8F0",
      success: "#22C55E",
      error: "#EF4444",
      warning: "#F59E0B",
    },
    fonts: { heading: "Plus Jakarta Sans, sans-serif", body: "Inter, sans-serif", mono: "Fira Code, monospace" },
    radii: { sm: "8px", md: "12px", lg: "16px", full: "9999px" },
    shadows: {
      sm: "0 1px 3px rgba(99,102,241,0.1)",
      md: "0 4px 12px rgba(99,102,241,0.15)",
      lg: "0 8px 24px rgba(99,102,241,0.2)",
    },
    timing: "200ms cubic-bezier(0.4, 0, 0.2, 1)",
    notes: "Vibrant gradients (primary → secondary), rounded corners, elevated cards with colored shadows.",
  },
  dashboard: {
    colors: {
      primary: "#3B82F6",
      secondary: "#1E40AF",
      background: "#F1F5F9",
      surface: "#FFFFFF",
      text: "#0F172A",
      "text-secondary": "#475569",
      border: "#CBD5E1",
      success: "#22C55E",
      error: "#EF4444",
      warning: "#EAB308",
    },
    fonts: { heading: "Inter, system-ui, sans-serif", body: "Inter, system-ui, sans-serif", mono: "IBM Plex Mono, monospace" },
    radii: { sm: "4px", md: "6px", lg: "8px", full: "9999px" },
    shadows: {
      sm: "0 1px 2px rgba(0,0,0,0.06)",
      md: "0 2px 4px rgba(0,0,0,0.08)",
      lg: "0 4px 8px rgba(0,0,0,0.12)",
    },
    timing: "150ms ease-in-out",
    notes: "Dense layouts, data tables, monospace accents for numbers/metrics. Sidebar navigation pattern.",
  },
  playful: {
    colors: {
      primary: "#F43F5E",
      secondary: "#A855F7",
      background: "#FFFBEB",
      surface: "#FFFFFF",
      text: "#1C1917",
      "text-secondary": "#78716C",
      border: "#FDE68A",
      success: "#34D399",
      error: "#FB7185",
      warning: "#FBBF24",
    },
    fonts: { heading: "Nunito, sans-serif", body: "Nunito, sans-serif", mono: "Fira Code, monospace" },
    radii: { sm: "8px", md: "16px", lg: "24px", full: "9999px" },
    shadows: {
      sm: "0 2px 4px rgba(244,63,94,0.1)",
      md: "0 4px 12px rgba(244,63,94,0.15)",
      lg: "0 8px 24px rgba(168,85,247,0.2)",
    },
    timing: "300ms cubic-bezier(0.34, 1.56, 0.64, 1)",
    notes: "Bright, warm colors. Bouncy animations with overshoot. Rounded everything. Emoji-friendly.",
  },
  industrial: {
    colors: {
      primary: "#06B6D4",
      secondary: "#0891B2",
      background: "#0A0A0A",
      surface: "#171717",
      text: "#FAFAFA",
      "text-secondary": "#A3A3A3",
      border: "#262626",
      success: "#22D3EE",
      error: "#F87171",
      warning: "#FBBF24",
    },
    fonts: { heading: "JetBrains Mono, monospace", body: "Inter, sans-serif", mono: "JetBrains Mono, monospace" },
    radii: { sm: "2px", md: "4px", lg: "6px", full: "9999px" },
    shadows: {
      sm: "0 1px 2px rgba(0,0,0,0.5)",
      md: "0 4px 8px rgba(0,0,0,0.6)",
      lg: "0 8px 16px rgba(0,0,0,0.7)",
    },
    timing: "100ms linear",
    notes: "Dark mode by default. Monospace headings. Cyan accent color. Terminal/hacker aesthetic. Minimal animations.",
  },
  glassmorphism: {
    colors: {
      primary: "#7C3AED",
      secondary: "#2DD4BF",
      background: "#0F172A",
      surface: "rgba(255,255,255,0.05)",
      text: "#F8FAFC",
      "text-secondary": "#94A3B8",
      border: "rgba(255,255,255,0.1)",
      success: "#34D399",
      error: "#FB7185",
      warning: "#FBBF24",
    },
    fonts: { heading: "Plus Jakarta Sans, sans-serif", body: "Inter, sans-serif", mono: "Fira Code, monospace" },
    radii: { sm: "12px", md: "16px", lg: "24px", full: "9999px" },
    shadows: {
      sm: "0 2px 8px rgba(0,0,0,0.2)",
      md: "0 8px 32px rgba(0,0,0,0.3)",
      lg: "0 16px 48px rgba(0,0,0,0.4)",
    },
    timing: "250ms cubic-bezier(0.4, 0, 0.2, 1)",
    notes: "Frosted glass cards with backdrop-blur(12px). Translucent surfaces. Gradient mesh backgrounds. Glow effects on hover.",
  },
  neobrutalism: {
    colors: {
      primary: "#FF6B00",
      secondary: "#FFD600",
      background: "#FEFCE8",
      surface: "#FFFFFF",
      text: "#000000",
      "text-secondary": "#404040",
      border: "#000000",
      success: "#16A34A",
      error: "#DC2626",
      warning: "#CA8A04",
    },
    fonts: { heading: "Space Grotesk, sans-serif", body: "DM Sans, sans-serif", mono: "Space Mono, monospace" },
    radii: { sm: "0px", md: "4px", lg: "8px", full: "9999px" },
    shadows: {
      sm: "2px 2px 0px #000000",
      md: "4px 4px 0px #000000",
      lg: "6px 6px 0px #000000",
    },
    timing: "100ms ease",
    notes: "Thick black borders (2-3px). Bold, flat offset shadows. High contrast. No gradients. Raw, bold aesthetic.",
  },
  bento: {
    colors: {
      primary: "#18181B",
      secondary: "#3F3F46",
      background: "#FAFAFA",
      surface: "#FFFFFF",
      text: "#18181B",
      "text-secondary": "#71717A",
      border: "#E4E4E7",
      success: "#22C55E",
      error: "#EF4444",
      warning: "#F59E0B",
    },
    fonts: { heading: "Instrument Sans, sans-serif", body: "Inter, sans-serif", mono: "GeistMono, monospace" },
    radii: { sm: "8px", md: "16px", lg: "24px", full: "9999px" },
    shadows: {
      sm: "0 1px 3px rgba(0,0,0,0.04)",
      md: "0 4px 12px rgba(0,0,0,0.06)",
      lg: "0 8px 24px rgba(0,0,0,0.08)",
    },
    timing: "200ms ease-out",
    notes: "Grid-based card layouts (CSS Grid). Clean spacing. Modular blocks. Hover lift effects. Apple-inspired minimalism.",
  },
  neumorphism: {
    colors: {
      primary: "#6366F1",
      secondary: "#818CF8",
      background: "#E0E5EC",
      surface: "#E0E5EC",
      text: "#2D3748",
      "text-secondary": "#718096",
      border: "transparent",
      success: "#48BB78",
      error: "#FC8181",
      warning: "#F6E05E",
    },
    fonts: { heading: "Poppins, sans-serif", body: "Inter, sans-serif", mono: "Fira Code, monospace" },
    radii: { sm: "12px", md: "16px", lg: "24px", full: "9999px" },
    shadows: {
      sm: "4px 4px 8px #b8bec7, -4px -4px 8px #ffffff",
      md: "6px 6px 12px #b8bec7, -6px -6px 12px #ffffff",
      lg: "8px 8px 16px #b8bec7, -8px -8px 16px #ffffff",
    },
    timing: "200ms ease",
    notes: "Soft extruded UI elements. Muted color palette. Dual shadows (light + dark). Pressed/inset state for active elements.",
  },
};

export function generateFrontendGuidelines(contract: Contract): string {
  const s: string[] = [];
  const style = contract.uiStyle || "modern";
  const tokens = DESIGN_TOKENS[style] || DESIGN_TOKENS["modern"];

  s.push(`# FRONTEND_GUIDELINES.md — ${contract.archetype} MVP`);
  s.push(`\n> Design system, component patterns, and frontend conventions for the "${style}" aesthetic.`);

  s.push(`\n## 1. Design System: "${style}"`);
  s.push(`\n${tokens.notes}`);

  s.push(`\n## 2. Color Palette`);
  s.push(`\n| Token | Value | Usage |`);
  s.push(`|-------|-------|-------|`);
  s.push(`| \`--color-primary\` | \`${tokens.colors.primary}\` | Primary actions, links, active states |`);
  s.push(`| \`--color-secondary\` | \`${tokens.colors.secondary}\` | Secondary actions, accents |`);
  s.push(`| \`--color-background\` | \`${tokens.colors.background}\` | Page background |`);
  s.push(`| \`--color-surface\` | \`${tokens.colors.surface}\` | Card and panel backgrounds |`);
  s.push(`| \`--color-text\` | \`${tokens.colors.text}\` | Primary text |`);
  s.push(`| \`--color-text-secondary\` | \`${tokens.colors["text-secondary"]}\` | Secondary / muted text |`);
  s.push(`| \`--color-border\` | \`${tokens.colors.border}\` | Borders, dividers |`);
  s.push(`| \`--color-success\` | \`${tokens.colors.success}\` | Success states, confirmations |`);
  s.push(`| \`--color-error\` | \`${tokens.colors.error}\` | Error states, destructive actions |`);
  s.push(`| \`--color-warning\` | \`${tokens.colors.warning}\` | Warning states, caution |`);

  s.push(`\n## 3. Typography`);
  s.push(`\n| Element | Font Family | Size | Weight |`);
  s.push(`|---------|-------------|------|--------|`);
  s.push(`| H1 | ${tokens.fonts.heading} | 36px / 2.25rem | 700 |`);
  s.push(`| H2 | ${tokens.fonts.heading} | 30px / 1.875rem | 600 |`);
  s.push(`| H3 | ${tokens.fonts.heading} | 24px / 1.5rem | 600 |`);
  s.push(`| H4 | ${tokens.fonts.heading} | 20px / 1.25rem | 600 |`);
  s.push(`| Body | ${tokens.fonts.body} | 16px / 1rem | 400 |`);
  s.push(`| Small | ${tokens.fonts.body} | 14px / 0.875rem | 400 |`);
  s.push(`| Code | ${tokens.fonts.mono} | 14px / 0.875rem | 400 |`);

  s.push(`\n## 4. Spacing Scale`);
  s.push(`\n| Token | Value |`);
  s.push(`|-------|-------|`);
  s.push(`| \`--space-1\` | 4px |`);
  s.push(`| \`--space-2\` | 8px |`);
  s.push(`| \`--space-3\` | 12px |`);
  s.push(`| \`--space-4\` | 16px |`);
  s.push(`| \`--space-6\` | 24px |`);
  s.push(`| \`--space-8\` | 32px |`);
  s.push(`| \`--space-12\` | 48px |`);
  s.push(`| \`--space-16\` | 64px |`);

  s.push(`\n## 5. Border Radius`);
  s.push(`\n| Token | Value |`);
  s.push(`|-------|-------|`);
  Object.entries(tokens.radii).forEach(([key, value]) => {
    s.push(`| \`--radius-${key}\` | ${value} |`);
  });

  s.push(`\n## 6. Shadows`);
  s.push(`\n| Token | Value |`);
  s.push(`|-------|-------|`);
  Object.entries(tokens.shadows).forEach(([key, value]) => {
    s.push(`| \`--shadow-${key}\` | \`${value}\` |`);
  });

  s.push(`\n## 7. Animation & Transitions`);
  s.push(`\n- **Default transition:** \`${tokens.timing}\``);
  s.push(`- **Hover states:** Apply transition to \`background-color\`, \`border-color\`, \`box-shadow\`, \`transform\``);
  s.push(`- **Page transitions:** Fade in with 200ms duration`);
  s.push(`- **Loading states:** Pulse animation at 1.5s interval`);
  s.push(`- **Micro-interactions:** Scale 1.02 on card hover, 0.97 on button press`);

  s.push(`\n## 8. Component Patterns`);
  s.push(`\n### Buttons`);
  s.push(`- **Primary:** Filled with \`--color-primary\`, white text`);
  s.push(`- **Secondary:** Outlined with \`--color-border\`, \`--color-text\``);
  s.push(`- **Ghost:** No background, text-only with hover highlight`);
  s.push(`- **Destructive:** Filled with \`--color-error\`, white text`);
  s.push(`- All buttons: \`--radius-md\`, padding \`--space-2\` \`--space-4\`, font-weight 500`);

  s.push(`\n### Cards`);
  s.push(`- Background: \`--color-surface\``);
  s.push(`- Border: 1px solid \`--color-border\``);
  s.push(`- Border radius: \`--radius-lg\``);
  s.push(`- Shadow: \`--shadow-sm\``);
  s.push(`- Padding: \`--space-6\``);
  s.push(`- Hover: Elevate to \`--shadow-md\``);

  s.push(`\n### Forms`);
  s.push(`- Input height: 40px`);
  s.push(`- Input border: 1px solid \`--color-border\``);
  s.push(`- Input radius: \`--radius-md\``);
  s.push(`- Focus ring: 2px solid \`--color-primary\` with 2px offset`);
  s.push(`- Label: font-weight 500, margin-bottom \`--space-1\``);
  s.push(`- Error text: \`--color-error\`, 14px, below input`);

  s.push(`\n### Tables`);
  s.push(`- Header: font-weight 600, \`--color-text-secondary\`, uppercase, 12px`);
  s.push(`- Row hover: \`--color-surface\` background`);
  s.push(`- Border: Bottom border on rows using \`--color-border\``);
  s.push(`- Cell padding: \`--space-3\` \`--space-4\``);

  s.push(`\n## 9. Responsive Breakpoints`);
  s.push(`\n| Breakpoint | Range | Layout |`);
  s.push(`|------------|-------|--------|`);
  s.push(`| Mobile | 0 – 640px | Single column, stacked navigation |`);
  s.push(`| Tablet | 640px – 1024px | Two column, collapsible sidebar |`);
  s.push(`| Desktop | 1024px+ | Full layout, persistent navigation |`);
  s.push(`\n- Mobile-first approach: Start with mobile styles, add complexity at larger breakpoints.`);
  s.push(`- Touch targets: Minimum 44x44px on mobile.`);
  s.push(`- Font scaling: Base 16px, no smaller than 14px on mobile.`);

  s.push(`\n## 10. Dark / Light Mode`);
  const isDarkDefault = ["industrial", "glassmorphism"].includes(style);
  if (isDarkDefault) {
    s.push(`\n**Default: Dark mode** (matches the "${style}" aesthetic).`);
    s.push(`\nLight mode is optional for this style. If implemented:`);
    s.push(`- Invert background and text colors`);
    s.push(`- Reduce shadow intensity`);
    s.push(`- Adjust surface colors for contrast`);
  } else {
    s.push(`\n**Default: Light mode.**`);
    s.push(`\nFor dark mode support:`);
    s.push(`- Background: Shift to dark neutrals (#0F172A or #171717)`);
    s.push(`- Surface: Slightly lighter than background (#1E293B or #262626)`);
    s.push(`- Text: Invert to light (#F8FAFC or #FAFAFA)`);
    s.push(`- Borders: Lower opacity or darker neutral (#334155 or #404040)`);
    s.push(`- Preserve primary/secondary/accent colors`);
    s.push(`- Use \`prefers-color-scheme\` media query or manual toggle`);
  }

  s.push(`\n---\n*Generated by VibeForge*`);
  return s.join("\n");
}

function inferFieldType(field: string): string {
  const f = field.toLowerCase();
  if (f === "id") return "SERIAL PRIMARY KEY";
  if (f.endsWith("_id") || f.endsWith("Id")) return "INTEGER REFERENCES ... NOT NULL";
  if (f.includes("email")) return "VARCHAR(255) UNIQUE NOT NULL";
  if (f.includes("password") || f.includes("hash")) return "VARCHAR(255) NOT NULL";
  if (f.includes("name") || f.includes("title") || f.includes("label")) return "VARCHAR(255) NOT NULL";
  if (f.includes("description") || f.includes("bio") || f.includes("content") || f.includes("body") || f.includes("text")) return "TEXT";
  if (f.includes("url") || f.includes("link") || f.includes("image") || f.includes("avatar") || f.includes("photo")) return "VARCHAR(512)";
  if (f.includes("price") || f.includes("amount") || f.includes("cost") || f.includes("total")) return "DECIMAL(10,2) NOT NULL DEFAULT 0";
  if (f.includes("count") || f.includes("quantity") || f.includes("views") || f.includes("likes")) return "INTEGER NOT NULL DEFAULT 0";
  if (f.includes("is_") || f.includes("has_") || f.includes("active") || f.includes("enabled") || f.includes("verified") || f.includes("published")) return "BOOLEAN NOT NULL DEFAULT FALSE";
  if (f.includes("date") || f.includes("_at") || f.includes("created") || f.includes("updated") || f.includes("timestamp")) return "TIMESTAMP NOT NULL DEFAULT NOW()";
  if (f.includes("status")) return "VARCHAR(50) NOT NULL DEFAULT 'active'";
  if (f.includes("type") || f.includes("category") || f.includes("role")) return "VARCHAR(100) NOT NULL";
  if (f.includes("rating") || f.includes("score")) return "DECIMAL(3,2)";
  if (f.includes("tags") || f.includes("labels")) return "TEXT[]";
  if (f.includes("metadata") || f.includes("config") || f.includes("settings") || f.includes("data")) return "JSONB";
  return "VARCHAR(255)";
}

export function generateBackendStructure(contract: Contract): string {
  const s: string[] = [];

  s.push(`# BACKEND_STRUCTURE.md — ${contract.archetype} MVP`);
  s.push(`\n> Database schema, API endpoints, authentication, and backend architecture.`);

  s.push(`\n## 1. Database Schema`);
  if (contract.entities.length > 0) {
    contract.entities.forEach(entity => {
      const tableName = entity.name.toLowerCase().replace(/\s+/g, "_");
      s.push(`\n### \`${tableName}\``);
      s.push(`\n| Column | Type | Constraints |`);
      s.push(`|--------|------|-------------|`);
      const hasId = entity.fields.some(f => f.toLowerCase() === "id");
      if (!hasId) {
        s.push(`| id | SERIAL | PRIMARY KEY |`);
      }
      entity.fields.forEach(field => {
        const colName = field.toLowerCase().replace(/\s+/g, "_");
        const colType = inferFieldType(field);
        const parts = colType.split(" ");
        const type = parts[0];
        const constraints = parts.slice(1).join(" ") || "-";
        s.push(`| ${colName} | ${type} | ${constraints} |`);
      });
      const hasCreated = entity.fields.some(f => f.toLowerCase().includes("created"));
      const hasUpdated = entity.fields.some(f => f.toLowerCase().includes("updated"));
      if (!hasCreated) {
        s.push(`| created_at | TIMESTAMP | NOT NULL DEFAULT NOW() |`);
      }
      if (!hasUpdated) {
        s.push(`| updated_at | TIMESTAMP | NOT NULL DEFAULT NOW() |`);
      }
    });
  }

  if (contract.auth !== "none") {
    const hasUserEntity = contract.entities.some(e => e.name.toLowerCase().includes("user"));
    if (!hasUserEntity) {
      s.push(`\n### \`users\` (auto-generated for auth)`);
      s.push(`\n| Column | Type | Constraints |`);
      s.push(`|--------|------|-------------|`);
      s.push(`| id | SERIAL | PRIMARY KEY |`);
      s.push(`| email | VARCHAR(255) | UNIQUE NOT NULL |`);
      if (contract.auth === "email_password") {
        s.push(`| password_hash | VARCHAR(255) | NOT NULL |`);
      }
      if (contract.auth === "oauth_google") {
        s.push(`| google_id | VARCHAR(255) | UNIQUE |`);
      }
      s.push(`| display_name | VARCHAR(255) | NOT NULL |`);
      if (contract.roles.length > 1) {
        s.push(`| role | VARCHAR(100) | NOT NULL DEFAULT '${contract.roles[0] || "user"}' |`);
      }
      s.push(`| created_at | TIMESTAMP | NOT NULL DEFAULT NOW() |`);
      s.push(`| updated_at | TIMESTAMP | NOT NULL DEFAULT NOW() |`);
    }

    s.push(`\n### \`sessions\``);
    s.push(`\n| Column | Type | Constraints |`);
    s.push(`|--------|------|-------------|`);
    s.push(`| id | VARCHAR(255) | PRIMARY KEY |`);
    s.push(`| user_id | INTEGER | REFERENCES users(id) NOT NULL |`);
    s.push(`| expires_at | TIMESTAMP | NOT NULL |`);
    s.push(`| created_at | TIMESTAMP | NOT NULL DEFAULT NOW() |`);
  }

  s.push(`\n## 2. Entity Relationships`);
  if (contract.entities.length > 1) {
    s.push(`\nInferred relationships based on entity fields:`);
    contract.entities.forEach(entity => {
      entity.fields.forEach(field => {
        if (field.toLowerCase().endsWith("_id") || field.toLowerCase().endsWith("Id")) {
          const refName = field.replace(/_?[Ii]d$/, "").toLowerCase();
          const refEntity = contract.entities.find(e => e.name.toLowerCase().includes(refName));
          if (refEntity) {
            s.push(`- \`${entity.name}\`.${field} → \`${refEntity.name}\`.id (Many-to-One)`);
          } else {
            s.push(`- \`${entity.name}\`.${field} → (references external entity)`);
          }
        }
      });
    });
    if (contract.auth !== "none") {
      contract.entities.forEach(entity => {
        const hasUserId = entity.fields.some(f => f.toLowerCase().includes("user"));
        if (hasUserId) {
          s.push(`- \`${entity.name}\` belongs to \`users\``);
        }
      });
    }
  } else {
    s.push(`\nSingle entity — no inter-entity relationships.`);
    if (contract.auth !== "none") {
      s.push(`- All entities implicitly belong to \`users\` via user_id foreign key.`);
    }
  }

  s.push(`\n## 3. API Endpoints`);
  if (contract.entities.length > 0) {
    contract.entities.forEach(entity => {
      const resource = entity.name.toLowerCase().replace(/\s+/g, "-");
      const plural = resource.endsWith("s") ? resource : resource + "s";
      s.push(`\n### ${entity.name}`);
      s.push(`\n| Method | Endpoint | Description | Auth |`);
      s.push(`|--------|----------|-------------|------|`);
      s.push(`| GET | \`/api/${plural}\` | List all ${plural} (with pagination) | ${contract.auth !== "none" ? "Required" : "Public"} |`);
      s.push(`| GET | \`/api/${plural}/:id\` | Get single ${resource} by ID | ${contract.auth !== "none" ? "Required" : "Public"} |`);
      s.push(`| POST | \`/api/${plural}\` | Create new ${resource} | ${contract.auth !== "none" ? "Required" : "Public"} |`);
      s.push(`| PUT | \`/api/${plural}/:id\` | Update ${resource} | ${contract.auth !== "none" ? "Required (owner)" : "Public"} |`);
      s.push(`| DELETE | \`/api/${plural}/:id\` | Delete ${resource} | ${contract.auth !== "none" ? "Required (owner)" : "Public"} |`);
    });
  }

  if (contract.auth !== "none") {
    s.push(`\n### Authentication`);
    s.push(`\n| Method | Endpoint | Description |`);
    s.push(`|--------|----------|-------------|`);
    s.push(`| POST | \`/api/auth/register\` | Create new user account |`);
    s.push(`| POST | \`/api/auth/login\` | Authenticate and create session |`);
    s.push(`| POST | \`/api/auth/logout\` | Destroy current session |`);
    s.push(`| GET | \`/api/auth/me\` | Get current authenticated user |`);
    if (contract.auth === "oauth_google") {
      s.push(`| GET | \`/api/auth/google\` | Initiate Google OAuth flow |`);
      s.push(`| GET | \`/api/auth/google/callback\` | Handle OAuth callback |`);
    }
    if (contract.auth === "magic_link") {
      s.push(`| POST | \`/api/auth/magic-link\` | Send magic link email |`);
      s.push(`| GET | \`/api/auth/verify/:token\` | Verify magic link token |`);
    }
  }

  if (contract.coreFlows.length > 0) {
    s.push(`\n### Special Flow Endpoints`);
    s.push(`\n| Method | Endpoint | Description |`);
    s.push(`|--------|----------|-------------|`);
    contract.coreFlows.forEach(flow => {
      const slug = flow.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
      s.push(`| POST | \`/api/flows/${slug}\` | Execute: ${flow} |`);
    });
  }

  s.push(`\n## 4. Authentication Strategy`);
  if (contract.auth === "none") {
    s.push(`\nNo authentication required. All endpoints are public.`);
  } else if (contract.auth === "email_password") {
    s.push(`\n**Strategy:** Email + Password with session-based auth`);
    s.push(`- Passwords hashed with bcrypt (12 rounds)`);
    s.push(`- Sessions stored in database with 7-day expiry`);
    s.push(`- Session token sent via HTTP-only secure cookie`);
    s.push(`- CSRF protection via SameSite cookie attribute`);
    s.push(`- Rate limiting on login endpoint (5 attempts per 15 minutes)`);
  } else if (contract.auth === "oauth_google") {
    s.push(`\n**Strategy:** Google OAuth 2.0`);
    s.push(`- OAuth 2.0 authorization code flow`);
    s.push(`- Requires GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET env vars`);
    s.push(`- User record created on first login`);
    s.push(`- Sessions stored in database with 7-day expiry`);
  } else if (contract.auth === "magic_link") {
    s.push(`\n**Strategy:** Magic Link (passwordless)`);
    s.push(`- One-time token sent via email (valid for 15 minutes)`);
    s.push(`- Requires email sending service (SendGrid, Resend, etc.)`);
    s.push(`- Token is single-use and expires after verification`);
    s.push(`- Sessions stored in database with 7-day expiry`);
  }

  s.push(`\n## 5. Validation & Edge Cases`);
  s.push(`\n### Input Validation`);
  s.push(`- All request bodies validated using Zod schemas`);
  s.push(`- String fields: Trim whitespace, enforce max length`);
  s.push(`- Email fields: RFC 5322 format validation`);
  s.push(`- Numeric fields: Type coercion, range validation`);
  s.push(`- Arrays: Max length limits, item validation`);
  s.push(`\n### Error Handling`);
  s.push(`- 400: Validation errors with field-level details`);
  s.push(`- 401: Unauthorized — missing or invalid session`);
  s.push(`- 403: Forbidden — insufficient permissions`);
  s.push(`- 404: Resource not found`);
  s.push(`- 409: Conflict — duplicate unique constraint`);
  s.push(`- 500: Internal server error — logged but not exposed`);
  s.push(`\n### Edge Cases`);
  s.push(`- Concurrent updates: Use database-level constraints and transactions`);
  s.push(`- Large payloads: Enforce max body size (1MB default)`);
  s.push(`- Empty responses: Return empty arrays for list endpoints, 404 for single resources`);
  s.push(`- Pagination: Default 20 items per page, max 100, cursor-based for large datasets`);

  s.push(`\n---\n*Generated by VibeForge*`);
  return s.join("\n");
}

export function generateImplementationPlan(contract: Contract): string {
  const s: string[] = [];

  s.push(`# IMPLEMENTATION_PLAN.md — ${contract.archetype} MVP`);
  s.push(`\n> Phased build order. Each step references the relevant canonical doc.`);

  s.push(`\n## Phase 1: Project Setup`);
  s.push(`\n- **1.1** Initialize project repository and folder structure`);
  s.push(`  → Reference: TECH_STACK.md`);
  s.push(`- **1.2** Install all dependencies (frontend, backend, database)`);
  s.push(`  → Reference: TECH_STACK.md`);
  s.push(`- **1.3** Configure environment variables and secrets`);
  s.push(`  → Reference: TECH_STACK.md`);
  s.push(`- **1.4** Set up development tools (linting, formatting, TypeScript config)`);
  s.push(`  → Reference: TECH_STACK.md`);
  s.push(`- **1.5** Create all canonical documentation files (PRD, APP_FLOW, etc.)`);

  s.push(`\n## Phase 2: Database & Schema`);
  s.push(`\n- **2.1** Define database schema for all entities:`);
  contract.entities.forEach(e => {
    s.push(`  - \`${e.name}\`: ${e.fields.join(", ")}`);
  });
  s.push(`  → Reference: BACKEND_STRUCTURE.md (Section 1)`);
  s.push(`- **2.2** Set up ORM configuration and database connection`);
  s.push(`  → Reference: TECH_STACK.md (Database section)`);
  s.push(`- **2.3** Run initial migration to create all tables`);
  s.push(`- **2.4** Add seed data for development testing`);
  s.push(`- **2.5** Verify database schema matches BACKEND_STRUCTURE.md`);

  s.push(`\n## Phase 3: Backend API Routes`);
  s.push(`\n- **3.1** Create storage interface with CRUD operations for each entity`);
  s.push(`  → Reference: BACKEND_STRUCTURE.md (Section 3)`);
  s.push(`- **3.2** Implement API routes:`);
  contract.entities.forEach(e => {
    const resource = e.name.toLowerCase().replace(/\s+/g, "-");
    const plural = resource.endsWith("s") ? resource : resource + "s";
    s.push(`  - \`/api/${plural}\` — Full CRUD`);
  });
  s.push(`- **3.3** Add request validation using Zod schemas`);
  s.push(`  → Reference: BACKEND_STRUCTURE.md (Section 5)`);
  s.push(`- **3.4** Add error handling middleware`);
  s.push(`- **3.5** Test all endpoints with sample data`);

  s.push(`\n## Phase 4: Frontend Components`);
  s.push(`\n- **4.1** Set up routing with all pages from APP_FLOW.md`);
  s.push(`  → Reference: APP_FLOW.md (Section 1)`);
  s.push(`- **4.2** Build shared layout components (header, sidebar, footer)`);
  s.push(`  → Reference: FRONTEND_GUIDELINES.md`);
  s.push(`- **4.3** Create reusable UI components (buttons, cards, forms, tables)`);
  s.push(`  → Reference: FRONTEND_GUIDELINES.md (Section 8)`);
  s.push(`- **4.4** Build page-specific components for ${contract.archetype}:`);
  const routes = deriveRoutes(contract.archetype, contract.coreFlows, contract.auth);
  routes.filter(r => !r.path.includes("login") && !r.path.includes("register")).forEach(r => {
    s.push(`  - ${r.page} (\`${r.path}\`)`);
  });
  s.push(`- **4.5** Connect frontend to backend API using TanStack Query / fetch`);

  s.push(`\n## Phase 5: Core Flows Integration`);
  s.push(`\n- **5.1** Implement core flows end-to-end:`);
  contract.coreFlows.forEach((flow, i) => {
    s.push(`  - **5.1.${i + 1}** ${flow}`);
    s.push(`    → Reference: APP_FLOW.md (Flow ${i + 1})`);
  });
  s.push(`- **5.2** Add loading states and error handling for each flow`);
  s.push(`- **5.3** Add success/error toast notifications`);
  s.push(`- **5.4** Test each flow from UI through API to database and back`);

  if (contract.auth !== "none") {
    s.push(`\n## Phase 6: Authentication`);
    s.push(`\n- **6.1** Implement auth strategy: ${contract.auth}`);
    s.push(`  → Reference: BACKEND_STRUCTURE.md (Section 4), APP_FLOW.md (Section 5)`);
    s.push(`- **6.2** Build login and registration pages`);
    s.push(`- **6.3** Add session management (create, validate, destroy)`);
    s.push(`- **6.4** Protect API routes with auth middleware`);
    s.push(`- **6.5** Add frontend auth guards for protected pages`);
    if (contract.roles.length > 1) {
      s.push(`- **6.6** Implement role-based access control for: ${contract.roles.join(", ")}`);
    }
  }

  s.push(`\n## Phase 7: Styling & Polish`);
  s.push(`\n- **7.1** Apply "${contract.uiStyle}" design system tokens`);
  s.push(`  → Reference: FRONTEND_GUIDELINES.md (Sections 2–7)`);
  s.push(`- **7.2** Implement responsive layouts for mobile, tablet, desktop`);
  s.push(`  → Reference: FRONTEND_GUIDELINES.md (Section 9)`);
  s.push(`- **7.3** Add empty states, loading skeletons, and error boundaries`);
  s.push(`- **7.4** Add hover effects, transitions, and micro-interactions`);
  s.push(`- **7.5** Cross-browser testing and accessibility review`);

  s.push(`\n## Phase 8: Testing & QA`);
  s.push(`\n- **8.1** Verify all acceptance criteria:`);
  contract.definitionOfDone.forEach((d, i) => {
    s.push(`  - [ ] AC-${i + 1}: ${d}`);
  });
  s.push(`  → Reference: PRD.md (Section 12)`);
  s.push(`- **8.2** Test all core flows end-to-end`);
  s.push(`  → Reference: APP_FLOW.md (Section 2)`);
  s.push(`- **8.3** Test edge cases and error scenarios`);
  s.push(`  → Reference: BACKEND_STRUCTURE.md (Section 5)`);
  s.push(`- **8.4** Performance check: Page load < 3s, API response < 500ms`);
  s.push(`- **8.5** Security review: Input sanitization, auth flows, CSRF protection`);
  s.push(`- **8.6** Final deployment to ${contract.deployment}`);

  s.push(`\n---\n*Generated by VibeForge*`);
  return s.join("\n");
}

export function generateClaudeMd(contract: Contract, platform: PromptPlatform): string {
  const s: string[] = [];
  const config = PLATFORM_CONFIG[platform];
  const style = contract.uiStyle || "modern";
  const tokens = DESIGN_TOKENS[style] || DESIGN_TOKENS["modern"];
  const frontend = contract.stackPrefs.frontend || "React";
  const backend = contract.stackPrefs.backend || "Node.js + Express";
  const db = contract.stackPrefs.db || "PostgreSQL";

  s.push(`# CLAUDE.md — ${contract.archetype} MVP`);
  s.push(`\n> Project intelligence file for AI assistants. Read this before every task.`);

  s.push(`\n## Tech Stack`);
  s.push(`\n- **Frontend:** ${frontend}`);
  s.push(`- **Backend:** ${backend}`);
  s.push(`- **Database:** ${db}`);
  s.push(`- **Deployment:** ${contract.deployment}`);
  if (contract.auth !== "none") {
    s.push(`- **Auth:** ${contract.auth}`);
  }

  s.push(`\n## File Structure Conventions`);
  if (frontend.toLowerCase().includes("react")) {
    s.push(`\n\`\`\``);
    s.push(`client/`);
    s.push(`  src/`);
    s.push(`    components/    # Reusable UI components`);
    s.push(`    pages/         # Route-level page components`);
    s.push(`    hooks/         # Custom React hooks`);
    s.push(`    lib/           # Utilities, types, API client`);
    s.push(`    assets/        # Static assets`);
    s.push(`server/`);
    s.push(`  index.ts         # Server entry point`);
    s.push(`  routes.ts        # API route definitions`);
    s.push(`  storage.ts       # Database operations`);
    s.push(`shared/`);
    s.push(`  schema.ts        # Drizzle schema + Zod types`);
    s.push(`\`\`\``);
  } else {
    s.push(`\n\`\`\``);
    s.push(`src/`);
    s.push(`  components/      # UI components`);
    s.push(`  pages/           # Page components`);
    s.push(`  lib/             # Utilities and helpers`);
    s.push(`  api/             # API routes or client`);
    s.push(`\`\`\``);
  }

  s.push(`\n## Component Patterns`);
  s.push(`\n- One component per file, named export matching filename`);
  s.push(`- Props interface defined above component`);
  s.push(`- Use composition over inheritance`);
  s.push(`- Extract reusable logic into custom hooks`);
  s.push(`- Co-locate styles with components`);

  s.push(`\n## Naming Conventions`);
  s.push(`\n- **Components:** PascalCase (\`UserProfile.tsx\`)`);
  s.push(`- **Hooks:** camelCase with \`use\` prefix (\`useAuth.ts\`)`);
  s.push(`- **Utilities:** camelCase (\`formatDate.ts\`)`);
  s.push(`- **Constants:** UPPER_SNAKE_CASE`);
  s.push(`- **Database tables:** snake_case`);
  s.push(`- **API routes:** kebab-case (\`/api/user-profiles\`)`);
  s.push(`- **CSS classes:** kebab-case or Tailwind utilities`);
  s.push(`- **TypeScript types/interfaces:** PascalCase with \`I\` prefix optional`);

  s.push(`\n## Design Tokens (${style})`);
  s.push(`\n- Primary: \`${tokens.colors.primary}\``);
  s.push(`- Secondary: \`${tokens.colors.secondary}\``);
  s.push(`- Background: \`${tokens.colors.background}\``);
  s.push(`- Surface: \`${tokens.colors.surface}\``);
  s.push(`- Text: \`${tokens.colors.text}\``);
  s.push(`- Border: \`${tokens.colors.border}\``);
  s.push(`- Font heading: ${tokens.fonts.heading}`);
  s.push(`- Font body: ${tokens.fonts.body}`);
  s.push(`- Border radius: ${tokens.radii.md}`);
  s.push(`- ${tokens.notes}`);

  if (contract.nonGoals.length > 0) {
    s.push(`\n## Forbidden Actions`);
    s.push(`\nDo NOT implement any of the following:`);
    contract.nonGoals.forEach(n => {
      s.push(`- ❌ ${n}`);
    });
  }

  s.push(`\n## Canonical Documentation`);
  s.push(`\nRefer to these docs as the source of truth:`);
  s.push(`- **PRD.md** — Product requirements, user stories, acceptance criteria`);
  s.push(`- **APP_FLOW.md** — Screen inventory, user journeys, navigation`);
  s.push(`- **TECH_STACK.md** — Technology choices and versions`);
  s.push(`- **FRONTEND_GUIDELINES.md** — Design system, tokens, component patterns`);
  s.push(`- **BACKEND_STRUCTURE.md** — Database schema, API endpoints, auth`);
  s.push(`- **IMPLEMENTATION_PLAN.md** — Phased build order`);
  s.push(`- **progress.txt** — Current build status and next steps`);

  s.push(`\n## Platform Rules: ${config.name}`);
  config.platformRules.forEach(r => {
    s.push(`- ${r}`);
  });
  config.platformConstraints.forEach(c => {
    s.push(`- ${c}`);
  });
  s.push(`\n${config.stackNote}`);

  s.push(`\n## Progress Tracking`);
  s.push(`\nAfter completing each task:`);
  s.push(`1. Update \`progress.txt\` — move completed items, add new items`);
  s.push(`2. Check off acceptance criteria in PRD.md as they are met`);
  s.push(`3. Note any bugs or issues in the KNOWN BUGS section of progress.txt`);

  s.push(`\n---\n*Generated by VibeForge*`);
  return s.join("\n");
}

export function generateProgressTxt(contract: Contract): string {
  const s: string[] = [];

  s.push(`# progress.txt — ${contract.archetype} MVP`);
  s.push(`# Updated: ${new Date().toISOString().split("T")[0]}`);

  s.push(`\n## COMPLETED`);
  s.push(`- (none yet)`);

  s.push(`\n## IN PROGRESS`);
  s.push(`- Project setup and documentation`);

  s.push(`\n## NEXT`);
  s.push(`- [ ] Phase 1: Project setup — initialize repo, install dependencies, configure environment`);
  s.push(`- [ ] Phase 2: Database & schema — define tables for ${contract.entities.map(e => e.name).join(", ") || "entities"}`);
  s.push(`- [ ] Phase 3: Backend API — CRUD routes for all entities`);
  s.push(`- [ ] Phase 4: Frontend components — build pages and UI for ${contract.archetype}`);
  s.push(`- [ ] Phase 5: Core flows — implement ${contract.coreFlows.length > 0 ? contract.coreFlows.join(", ") : "all core user flows"}`);
  if (contract.auth !== "none") {
    s.push(`- [ ] Phase 6: Authentication — ${contract.auth} strategy`);
  }
  s.push(`- [ ] Phase 7: Styling & polish — apply ${contract.uiStyle} design system`);
  s.push(`- [ ] Phase 8: Testing & QA — verify all acceptance criteria`);

  s.push(`\n## KNOWN BUGS`);
  s.push(`- (none yet)`);

  return s.join("\n");
}
